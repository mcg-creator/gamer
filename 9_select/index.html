<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ROG Ally Demo</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="app">
    <div id="game-container">
      <div id="windows-shell">
        <div id="app-container">
          
          <!-- Top Navigation (inside app-container) -->
          <nav id="top-nav"></nav>
          
          <!-- App Content -->
          <main id="content">
            <!-- Games Carousel -->
            <div id="games-carousel" class="carousel-container">
              <div class="games-carousel-wrapper carousel-wrapper">
                <div class="games-carousel-track carousel-track">
                  <!-- Game cards will be dynamically generated here -->
                </div>
              </div>
            </div>
            
            <!-- Apps Carousel -->
            <div id="apps-carousel" class="carousel-container" style="display: none;">
              <div class="apps-carousel-wrapper carousel-wrapper">
                <div class="apps-carousel-track carousel-track">
                  <!-- App cards will be dynamically generated here -->
                </div>
              </div>
            </div>
            
            <!-- Friends Carousel -->
            <div id="friends-carousel" class="carousel-container" style="display: none;">
              <div class="friends-carousel-wrapper carousel-wrapper">
                <div class="friends-carousel-track carousel-track">
                  <!-- Friend cards will be dynamically generated here -->
                </div>
              </div>
            </div>
            
            <!-- Default Content for Other Tabs -->
            <div id="default-content" style="display: none;">Content</div>
          </main>

          <!-- Bottom Controls -->
          <div id="bottom-controls">
            <img id="control-image" src="" alt="Controls" />
          </div>

        </div>
      </div>
    </div>
  </div>
  
  <script>
    // Dynamic game detection system
    let games = [];
    let currentGameIndex = 0;
    
    // Predefined list of known games with nice titles - you can expand this
    const gameMetadata = {
      "halo": { title: "Halo", subtitle: "The Master Chief Collection" },
      "spiderman": { title: "Spider-Man", subtitle: "Miles Morales" },
      "starfield": { title: "Starfield", subtitle: "Space Adventure" },
      "sea_of_thieves": { title: "Sea of Thieves", subtitle: "Pirate Adventure" },
      "rainworld": { title: "Rain World", subtitle: "Survival Platformer" },
      "silksong": { title: "Hollow Knight", subtitle: "Silksong" },
      // Add more games here as needed
    };
    
    // Function to generate a nice title from filename if not in metadata
    function generateGameTitle(filename) {
      return filename
        .replace(/_/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }
    
    // Function to dynamically detect available games
    async function detectGames() {
      const detectedGames = [];
      
      // List of common image extensions
      const imageExtensions = ['png', 'jpg', 'jpeg', 'webp'];
      
      // We'll try to detect games by attempting to load images
      // This is a workaround since we can't directly read the filesystem from the browser
      const potentialGames = [
        'halo', 'spiderman', 'starfield', 'sea_of_thieves', 'rainworld', 'silksong',
        // Add more potential game names here as you add them
        'cyberpunk', 'witcher3', 'fallout4', 'skyrim', 'gta5', 'rdr2', 
        'doom', 'minecraft', 'fortnite', 'apex', 'valorant', 'overwatch',
        'destiny2', 'cod', 'battlefield', 'assassins_creed', 'far_cry',
        'horizon', 'ghost_of_tsushima', 'god_of_war', 'last_of_us',
        'uncharted', 'tomb_raider', 'mass_effect', 'elder_scrolls',
        'fallout', 'bioshock', 'dishonored', 'prey', 'deathloop'
      ];
      
      for (const gameName of potentialGames) {
        try {
          // Try to load the game image
          const gameImg = new Image();
          const bgImg = new Image();
          
          const gameImagePromise = new Promise((resolve) => {
            gameImg.onload = () => resolve(true);
            gameImg.onerror = () => resolve(false);
            gameImg.src = `assets/games/${gameName}.png`;
          });
          
          const bgImagePromise = new Promise((resolve) => {
            bgImg.onload = () => resolve(true);
            bgImg.onerror = () => resolve(false);
            bgImg.src = `assets/bg/games/${gameName}.png`;
          });
          
          const [gameExists, bgExists] = await Promise.all([gameImagePromise, bgImagePromise]);
          
          if (gameExists) {
            const gameData = gameMetadata[gameName] || {
              title: generateGameTitle(gameName),
              subtitle: "Adventure Game"
            };
            
            detectedGames.push({
              id: gameName,
              title: gameData.title,
              subtitle: gameData.subtitle,
              hasBackground: bgExists
            });
          }
        } catch (error) {
          console.log(`Skipping ${gameName}:`, error);
        }
      }
      
      return detectedGames;
    }
    
    // Function to dynamically create CSS for backgrounds
    function createDynamicCSS() {
      // Remove existing dynamic styles if any
      const existingStyle = document.getElementById('dynamic-game-styles');
      if (existingStyle) {
        existingStyle.remove();
      }
      
      const style = document.createElement('style');
      style.id = 'dynamic-game-styles';
      
      let css = '';
      
      // Add game backgrounds
      games.forEach(game => {
        if (game.hasBackground) {
          css += `
#game-container.bg-${game.id} {
    background-image: url('assets/bg/games/${game.id}.png');
}
`;
        }
      });
      
      // Add app backgrounds
      apps.forEach(app => {
        if (app.hasBackground) {
          css += `
#game-container.bg-${app.id} {
    background-image: url('assets/bg/apps/${app.id}.png');
}
`;
        }
      });
      
      // Add friend backgrounds
      friends.forEach(friend => {
        if (friend.hasBackground) {
          css += `
#game-container.bg-${friend.id} {
    background-image: url('assets/bg/friends/${friend.id}.png');
}
`;
        }
      });
      
      style.textContent = css;
      document.head.appendChild(style);
    }
    
    // Function to dynamically create game cards in HTML
    function createGameCards() {
      const carouselTrack = document.querySelector('.games-carousel-track');
      carouselTrack.innerHTML = ''; // Clear existing cards
      
      games.forEach(game => {
        const gameCard = document.createElement('div');
        gameCard.className = 'game-card';
        gameCard.dataset.game = game.id;
        
        const gameImage = document.createElement('img');
        gameImage.src = `assets/games/${game.id}.png`;
        gameImage.alt = game.title;
        gameImage.className = 'game-image';
        
        gameCard.appendChild(gameImage);
        carouselTrack.appendChild(gameCard);
      });
    }
    
    // Initialize the games system
    async function initializeGames() {
      console.log('ðŸŽ® Detecting available games...');
      games = await detectGames();
      console.log(`Found ${games.length} games:`, games.map(g => g.title));
      
      if (games.length === 0) {
        console.warn('No games detected! Make sure images are in assets/games/ folder');
        // Fallback to original hardcoded list
        games = [
          { id: "halo", title: "Halo", subtitle: "The Master Chief Collection", hasBackground: true }
        ];
      }
      
      createGameCards();
      updateGamesCarousel();
    }
    
    // Apps system - similar to games but for applications
    let apps = [];
    let currentAppIndex = 0;
    
    // Predefined list of known apps with nice titles
    const appMetadata = {
      "steam": { title: "Steam", subtitle: "Gaming Platform" },
      "xbox": { title: "Xbox", subtitle: "Gaming Platform" },
      "ea": { title: "EA App", subtitle: "Gaming Platform" },
      "discord": { title: "Discord", subtitle: "Voice & Text Chat" },
      "spotify": { title: "Spotify", subtitle: "Music Streaming" },
      "netflix": { title: "Netflix", subtitle: "Video Streaming" },
      "chrome": { title: "Chrome", subtitle: "Web Browser" },
      "vscode": { title: "VS Code", subtitle: "Code Editor" },
      "photoshop": { title: "Photoshop", subtitle: "Image Editor" },
      // Add more apps here as needed
    };
    
    // Function to generate a nice title from filename if not in metadata
    function generateAppTitle(filename) {
      return filename
        .replace(/_/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }
    
    // Function to dynamically detect available apps
    async function detectApps() {
      const detectedApps = [];
      
      // We'll try to detect apps by attempting to load images
      const potentialApps = [
        'xbox', 'discord', 'spotify', 'steam', 'ea', 'netflix',
        'chrome', 'firefox', 'edge', 'vscode', 'visual_studio', 
        'photoshop', 'illustrator', 'premiere', 'after_effects', 
        'blender', 'unity', 'unreal', 'gimp', 'obs', 'streamlabs', 
        'twitch', 'youtube', 'zoom', 'teams', 'slack', 'notion', 
        'excel', 'word'
      ];
      
      for (const appName of potentialApps) {
        try {
          const appImg = new Image();
          const bgImg = new Image();
          
          const appImagePromise = new Promise((resolve) => {
            appImg.onload = () => resolve(true);
            appImg.onerror = () => resolve(false);
            appImg.src = `assets/apps/${appName}.png`;
          });
          
          const bgImagePromise = new Promise((resolve) => {
            bgImg.onload = () => resolve(true);
            bgImg.onerror = () => resolve(false);
            bgImg.src = `assets/bg/apps/${appName}.png`;
          });
          
          const [appExists, bgExists] = await Promise.all([appImagePromise, bgImagePromise]);
          
          if (appExists) {
            const appData = appMetadata[appName] || {
              title: generateAppTitle(appName),
              subtitle: "Application"
            };
            
            detectedApps.push({
              id: appName,
              title: appData.title,
              subtitle: appData.subtitle,
              hasBackground: bgExists
            });
          }
        } catch (error) {
          console.log(`Could not load app: ${appName}`);
        }
      }
      
      return detectedApps;
    }
    
    function createAppCards() {
      const carouselTrack = document.querySelector('.apps-carousel-track');
      carouselTrack.innerHTML = ''; // Clear existing cards
      
      apps.forEach((app, index) => {
        const appCard = document.createElement('div');
        appCard.className = 'game-card';
        appCard.dataset.app = app.id;
        
        const appImage = document.createElement('img');
        appImage.src = `assets/apps/${app.id}.png`;
        appImage.alt = app.title;
        appImage.className = 'game-image';
        
        appCard.appendChild(appImage);
        carouselTrack.appendChild(appCard);
      });
    }
    
    async function initializeApps() {
      console.log('ðŸ“± Detecting available apps...');
      apps = await detectApps();
      console.log(`Found ${apps.length} apps:`, apps.map(a => a.title));
      
      if (apps.length === 0) {
        console.warn('No apps detected! Make sure images are in assets/apps/ folder');
        // Fallback to original hardcoded list
        apps = [
          { id: "steam", title: "Steam", subtitle: "Gaming Platform", hasBackground: false }
        ];
      }
      
      createAppCards();
      updateAppsCarousel();
    }
    
    // Friends system - similar to games and apps
    let friends = [];
    let currentFriendIndex = 0;
    
    // Predefined list of known friends with nice titles
    const friendMetadata = {
      "friend1": { title: "Alex", subtitle: "Online" },
      "friend2": { title: "Sarah", subtitle: "Playing Halo" },
      "friend3": { title: "Mike", subtitle: "Away" },
      "friend4": { title: "Jessica", subtitle: "Online" },
      "friend5": { title: "David", subtitle: "Offline" },
      "friend6": { title: "Emma", subtitle: "Playing Minecraft" },
      "friend7": { title: "Ryan", subtitle: "Playing Starfield" },
      "friend8": { title: "Zoe", subtitle: "Online" },
      // Add more friends here as needed
    };
    
    // Function to generate a nice title from filename if not in metadata
    function generateFriendTitle(filename) {
      return filename
        .replace(/_/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }
    
    // Function to dynamically detect available friends
    async function detectFriends() {
      const detectedFriends = [];
      
      const potentialFriends = [
        'friend1', 'friend2', 'friend3', 'friend4', 'friend5', 'friend6',
        // Add more potential friend names here as you add them
        'friend7', 'friend8', 'friend9', 'friend10'
      ];
      
      for (const friendName of potentialFriends) {
        try {
          const friendImg = new Image();
          const bgImg = new Image();
          
          const friendImagePromise = new Promise((resolve) => {
            friendImg.onload = () => resolve(true);
            friendImg.onerror = () => resolve(false);
            friendImg.src = `assets/friends/${friendName}.png`;
          });
          
          const bgImagePromise = new Promise((resolve) => {
            bgImg.onload = () => resolve(true);
            bgImg.onerror = () => resolve(false);
            bgImg.src = `assets/bg/friends/${friendName}.png`;
          });
          
          const [friendExists, bgExists] = await Promise.all([friendImagePromise, bgImagePromise]);
          
          if (friendExists) {
            const friendData = friendMetadata[friendName] || {
              title: generateFriendTitle(friendName),
              subtitle: "Online"
            };
            
            detectedFriends.push({
              id: friendName,
              title: friendData.title,
              subtitle: friendData.subtitle,
              hasBackground: bgExists
            });
          }
        } catch (error) {
          console.log(`Could not load friend: ${friendName}`);
        }
      }
      
      return detectedFriends;
    }
    
    function createFriendCards() {
      const carouselTrack = document.querySelector('.friends-carousel-track');
      carouselTrack.innerHTML = ''; // Clear existing cards
      
      friends.forEach((friend, index) => {
        const friendCard = document.createElement('div');
        friendCard.className = 'friend-card';
        friendCard.dataset.friend = friend.id;
        
        const friendImage = document.createElement('img');
        friendImage.src = `assets/friends/${friend.id}.png`;
        friendImage.alt = friend.title;
        friendImage.className = 'friend-image';
        
        friendCard.appendChild(friendImage);
        carouselTrack.appendChild(friendCard);
      });
    }
    
    async function initializeFriends() {
      console.log('ðŸ‘¥ Detecting available friends...');
      friends = await detectFriends();
      console.log(`Found ${friends.length} friends:`, friends.map(f => f.title));
      
      if (friends.length === 0) {
        console.warn('No friends detected! Make sure images are in assets/friends/ folder');
        // Fallback to original hardcoded list
        friends = [
          { id: "friend1", title: "Friend", subtitle: "Online", hasBackground: false }
        ];
      }
      
      createFriendCards();
      updateFriendsCarousel();
    }
    
    function updateAppsCarousel() {
      const appCards = document.querySelectorAll('.apps-carousel-track .game-card');
      const totalApps = appCards.length;
      const gameContainer = document.getElementById('game-container');
      
      if (totalApps === 0) return; // No apps to display
      
      // Update background based on current app
      const currentApp = apps[currentAppIndex];
      if (currentApp && gameContainer) {
        // Remove all background classes
        const existingBgClasses = Array.from(gameContainer.classList).filter(cls => cls.startsWith('bg-'));
        existingBgClasses.forEach(cls => gameContainer.classList.remove(cls));
        
        // Add the current app's background class if it has a background
        if (currentApp.hasBackground) {
          gameContainer.classList.add(`bg-${currentApp.id}`);
        }
      }
      
      appCards.forEach((card, index) => {
        // Remove all position classes
        card.classList.remove('center', 'left', 'right', 'hidden');
        
        // Calculate relative position
        const relativeIndex = (index - currentAppIndex + totalApps) % totalApps;
        
        // Get the app image element
        const appImage = card.querySelector('.game-image');
        const appId = card.dataset.app;
        
        if (relativeIndex === 0) {
          // Center position - use focus image only when carousel has focus
          card.classList.add('center');
          card.style.zIndex = '3';
          card.style.transform = '';
          card.style.opacity = '';
          if (appImage && appId) {
            if (navigationFocus === "carousel") {
              appImage.src = `assets/apps/${appId}_focus.png`;
            } else {
              appImage.src = `assets/apps/${appId}.png`;
            }
          }
        } else if (relativeIndex === totalApps - 1) {
          // Left position (previous item) - use regular image
          card.classList.add('left');
          card.style.zIndex = '1';
          card.style.transform = '';
          card.style.opacity = '';
          if (appImage && appId) {
            appImage.src = `assets/apps/${appId}.png`;
          }
        } else if (relativeIndex === 1) {
          // Right position (next item) - use regular image
          card.classList.add('right');
          card.style.zIndex = '1';
          card.style.transform = '';
          card.style.opacity = '';
          if (appImage && appId) {
            appImage.src = `assets/apps/${appId}.png`;
          }
        } else {
          // Hidden positions - use regular image
          card.classList.add('hidden');
          card.style.zIndex = '0';
          if (relativeIndex < totalApps / 2) {
            card.style.transform = 'translateX(2000px) scale(0.5)';
          } else {
            card.style.transform = 'translateX(-2000px) scale(0.5)';
          }
          card.style.opacity = '0';
          if (appImage && appId) {
            appImage.src = `assets/apps/${appId}.png`;
          }
        }
      });
    }
    
    function navigateAppsCarousel(direction) {
      const totalApps = apps.length;
      if (direction === 'right') {
        currentAppIndex = (currentAppIndex + 1) % totalApps;
      } else if (direction === 'left') {
        currentAppIndex = (currentAppIndex - 1 + totalApps) % totalApps;
      }
      updateAppsCarousel();
      updateBottomControls(); // Update button when navigating through apps
    }
    
    function updateFriendsCarousel() {
      const friendCards = document.querySelectorAll('.friends-carousel-track .friend-card');
      const totalFriends = friendCards.length;
      const gameContainer = document.getElementById('game-container');
      
      if (totalFriends === 0) return; // No friends to display
      
      // Update background based on current friend
      const currentFriend = friends[currentFriendIndex];
      if (currentFriend && gameContainer) {
        // Remove all background classes
        const existingBgClasses = Array.from(gameContainer.classList).filter(cls => cls.startsWith('bg-'));
        existingBgClasses.forEach(cls => gameContainer.classList.remove(cls));
        
        // Add the current friend's background class if it has a background
        if (currentFriend.hasBackground) {
          gameContainer.classList.add(`bg-${currentFriend.id}`);
        }
      }
      
      // First pass: immediately hide all cards that should be hidden
      friendCards.forEach((card, index) => {
        const relativeIndex = (index - currentFriendIndex + totalFriends) % totalFriends;
        
        // If this card should be hidden, hide it immediately without transition
        if (relativeIndex > 2 && relativeIndex < totalFriends - 2) {
          card.style.transition = 'none'; // Disable transitions
          card.style.opacity = '0';
          card.style.visibility = 'hidden';
          card.style.transform = 'translateX(0px) scale(0)';
          card.style.zIndex = '0';
        }
      });
      
      // Small delay to ensure hidden cards are processed, then position visible cards
      requestAnimationFrame(() => {
        friendCards.forEach((card, index) => {
          // Remove all position classes
          card.classList.remove('center', 'left', 'right', 'far-left', 'far-right', 'hidden');
          
          // Calculate relative position
          const relativeIndex = (index - currentFriendIndex + totalFriends) % totalFriends;
          
          // Get the friend image element
          const friendImage = card.querySelector('.friend-image');
          const friendId = card.dataset.friend;
          
          if (relativeIndex === 0) {
            // Center position - use focus image only when carousel has focus
            card.classList.add('center');
            card.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            card.style.zIndex = '5';
            card.style.transform = '';
            card.style.opacity = '1';
            card.style.visibility = 'visible';
            if (friendImage && friendId) {
              if (navigationFocus === "carousel") {
                friendImage.src = `assets/friends/${friendId}_focus.png`;
              } else {
                friendImage.src = `assets/friends/${friendId}.png`;
              }
            }
          } else if (relativeIndex === totalFriends - 1) {
            // Left position (previous item) - use regular image
            card.classList.add('left');
            card.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            card.style.zIndex = '3';
            card.style.transform = '';
            card.style.opacity = '1';
            card.style.visibility = 'visible';
            if (friendImage && friendId) {
              friendImage.src = `assets/friends/${friendId}.png`;
            }
          } else if (relativeIndex === 1) {
            // Right position (next item) - use regular image
            card.classList.add('right');
            card.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            card.style.zIndex = '3';
            card.style.transform = '';
            card.style.opacity = '1';
            card.style.visibility = 'visible';
            if (friendImage && friendId) {
              friendImage.src = `assets/friends/${friendId}.png`;
            }
          } else if (relativeIndex === totalFriends - 2) {
            // Far left peek position
            card.classList.add('far-left');
            card.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            card.style.zIndex = '1';
            card.style.transform = '';
            card.style.opacity = '1';
            card.style.visibility = 'visible';
            if (friendImage && friendId) {
              friendImage.src = `assets/friends/${friendId}.png`;
            }
          } else if (relativeIndex === 2) {
            // Far right peek position
            card.classList.add('far-right');
            card.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            card.style.zIndex = '1';
            card.style.transform = '';
            card.style.opacity = '1';
            card.style.visibility = 'visible';
            if (friendImage && friendId) {
              friendImage.src = `assets/friends/${friendId}.png`;
            }
          } else {
            // Hidden positions - keep them hidden
            card.classList.add('hidden');
            card.style.transition = 'none'; // No transition for hidden cards
            card.style.zIndex = '0';
            card.style.opacity = '0';
            card.style.visibility = 'hidden';
            card.style.transform = 'translateX(0px) scale(0)';
            if (friendImage && friendId) {
              friendImage.src = `assets/friends/${friendId}.png`;
            }
          }
        });
      });
    }
    
    function navigateFriendsCarousel(direction) {
      const totalFriends = friends.length;
      if (direction === 'right') {
        currentFriendIndex = (currentFriendIndex + 1) % totalFriends;
      } else if (direction === 'left') {
        currentFriendIndex = (currentFriendIndex - 1 + totalFriends) % totalFriends;
      }
      updateFriendsCarousel();
      updateBottomControls(); // Update button when navigating through friends
    }
    
    function updateGamesCarousel() {
      const gameCards = document.querySelectorAll('.games-carousel-track .game-card');
      const totalGames = gameCards.length;
      const gameContainer = document.getElementById('game-container');
      
      if (totalGames === 0) return; // No games to display
      
      // Update background based on current game
      const currentGame = games[currentGameIndex];
      if (currentGame && gameContainer) {
        // Remove all background classes
        const existingBgClasses = Array.from(gameContainer.classList).filter(cls => cls.startsWith('bg-'));
        existingBgClasses.forEach(cls => gameContainer.classList.remove(cls));
        
        // Add the current game's background class if it has a background
        if (currentGame.hasBackground) {
          gameContainer.classList.add(`bg-${currentGame.id}`);
        }
      }
      
      // First pass: immediately hide all cards that should be hidden
      gameCards.forEach((card, index) => {
        const relativeIndex = (index - currentGameIndex + totalGames) % totalGames;
        
        // If this card should be hidden, hide it immediately without transition
        if (relativeIndex > 1 && relativeIndex < totalGames - 1) {
          card.style.transition = 'none'; // Disable transitions
          card.style.opacity = '0';
          card.style.visibility = 'hidden';
          card.style.transform = 'translateX(0px) scale(0)';
          card.style.zIndex = '0';
        }
      });
      
      // Small delay to ensure hidden cards are processed, then position visible cards
      requestAnimationFrame(() => {
        gameCards.forEach((card, index) => {
          // Remove all position classes
          card.classList.remove('center', 'left', 'right', 'hidden');
          
          // Calculate relative position
          const relativeIndex = (index - currentGameIndex + totalGames) % totalGames;
          
          // Get the game image element
          const gameImage = card.querySelector('.game-image');
          const gameId = card.dataset.game;
          
          if (relativeIndex === 0) {
            // Center position - use focus image only when carousel has focus
            card.classList.add('center');
            card.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            card.style.zIndex = '3';
            card.style.transform = '';
            card.style.opacity = '1';
            card.style.visibility = 'visible';
            if (gameImage && gameId) {
              if (navigationFocus === "carousel") {
                gameImage.src = `assets/games/${gameId}_focus.png`;
              } else {
                gameImage.src = `assets/games/${gameId}.png`;
              }
            }
          } else if (relativeIndex === totalGames - 1) {
            // Left position (previous item) - use regular image
            card.classList.add('left');
            card.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            card.style.zIndex = '1';
            card.style.transform = '';
            card.style.opacity = '1';
            card.style.visibility = 'visible';
            if (gameImage && gameId) {
              gameImage.src = `assets/games/${gameId}.png`;
            }
          } else if (relativeIndex === 1) {
            // Right position (next item) - use regular image
            card.classList.add('right');
            card.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            card.style.zIndex = '1';
            card.style.transform = '';
            card.style.opacity = '1';
            card.style.visibility = 'visible';
            if (gameImage && gameId) {
              gameImage.src = `assets/games/${gameId}.png`;
            }
          } else {
            // Hidden positions - keep them hidden
            card.classList.add('hidden');
            card.style.transition = 'none'; // No transition for hidden cards
            card.style.zIndex = '0';
            card.style.opacity = '0';
            card.style.visibility = 'hidden';
            card.style.transform = 'translateX(0px) scale(0)';
            if (gameImage && gameId) {
              gameImage.src = `assets/games/${gameId}.png`;
            }
          }
        });
      });
    }

    function navigateGamesCarousel(direction) {
      const totalGames = games.length;
      if (direction === 'right') {
        currentGameIndex = (currentGameIndex + 1) % totalGames;
      } else if (direction === 'left') {
        currentGameIndex = (currentGameIndex - 1 + totalGames) % totalGames;
      }
      updateGamesCarousel();
    }

    // Navigation tabs logic
    const tabs = [
      "games", "apps", "friends", "gallery", "notifications", "settings", "copilot"
    ];

    let selectedIndex = 0;
    let navigationFocus = "nav"; // "nav" for navigation bar, "carousel" for games/apps carousel
    const nav = document.getElementById("top-nav");
    const content = document.getElementById("content");
    const gamesCarousel = document.getElementById("games-carousel");
    const appsCarousel = document.getElementById("apps-carousel");
    const defaultContent = document.getElementById("default-content");

    function renderNav() {
      nav.innerHTML = "";
      tabs.forEach((tab, i) => {
        const btn = document.createElement("button");
        btn.className = "nav-item" + (i === selectedIndex ? " is-active" : "");
        btn.dataset.index = i;

        // Choose correct image based on tab and focus state
        let state;
        if (i === selectedIndex) {
          if ((tab === "games" || tab === "apps") && navigationFocus === "carousel") {
            state = "active";
          } else {
            state = "select";
          }
        } else {
          state = "default";
        }
        const img = document.createElement("img");
        img.src = `assets/nav/${tab}_${state}.png`;
        img.alt = tab;
        btn.appendChild(img);

        btn.addEventListener("mouseenter", () => {
          img.src = `assets/nav/${tab}_active.png`;
        });
        btn.addEventListener("mouseleave", () => {
          if (i === selectedIndex) {
            if ((tab === "games" || tab === "apps") && navigationFocus === "carousel") {
              img.src = `assets/nav/${tab}_active.png`;
            } else {
              img.src = `assets/nav/${tab}_select.png`;
            }
          } else {
            img.src = `assets/nav/${tab}_default.png`;
          }
        });
        btn.addEventListener("click", () => selectTab(i));

        nav.appendChild(btn);
      });

      // Update content based on selected tab
      updateContent();
      updateFocusVisuals();
    }

    function updateContent() {
      const currentTab = tabs[selectedIndex];
      
      // Fade out all carousels and default content first
      const fadeOutDuration = 200; // milliseconds
      
      gamesCarousel.style.transition = `opacity ${fadeOutDuration}ms ease-out`;
      appsCarousel.style.transition = `opacity ${fadeOutDuration}ms ease-out`;
      const friendsCarousel = document.getElementById('friends-carousel');
      friendsCarousel.style.transition = `opacity ${fadeOutDuration}ms ease-out`;
      defaultContent.style.transition = `opacity ${fadeOutDuration}ms ease-out`;
      
      gamesCarousel.style.opacity = "0";
      appsCarousel.style.opacity = "0";
      friendsCarousel.style.opacity = "0";
      defaultContent.style.opacity = "0";
      
      // After fade out completes, switch content and fade in
      setTimeout(() => {
        // Hide all elements
        gamesCarousel.style.display = "none";
        appsCarousel.style.display = "none";
        friendsCarousel.style.display = "none";
        defaultContent.style.display = "none";
        
        if (currentTab === "games") {
          gamesCarousel.style.display = "flex";
          updateGamesCarousel();
          // Fade in games carousel
          setTimeout(() => {
            gamesCarousel.style.transition = `opacity ${fadeOutDuration}ms ease-in`;
            gamesCarousel.style.opacity = "1";
          }, 10); // Small delay to ensure display change takes effect
        } else if (currentTab === "apps") {
          appsCarousel.style.display = "flex";
          updateAppsCarousel();
          // Fade in apps carousel
          setTimeout(() => {
            appsCarousel.style.transition = `opacity ${fadeOutDuration}ms ease-in`;
            appsCarousel.style.opacity = "1";
          }, 10); // Small delay to ensure display change takes effect
        } else if (currentTab === "friends") {
          friendsCarousel.style.display = "flex";
          updateFriendsCarousel();
          // Fade in friends carousel
          setTimeout(() => {
            friendsCarousel.style.transition = `opacity ${fadeOutDuration}ms ease-in`;
            friendsCarousel.style.opacity = "1";
          }, 10); // Small delay to ensure display change takes effect
        } else {
          defaultContent.style.display = "flex";
          defaultContent.textContent = currentTab.charAt(0).toUpperCase() + currentTab.slice(1);
          // Reset focus to nav when not in games, apps, or friends tab
          navigationFocus = "nav";
          // Fade in default content
          setTimeout(() => {
            defaultContent.style.transition = `opacity ${fadeOutDuration}ms ease-in`;
            defaultContent.style.opacity = "1";
          }, 10); // Small delay to ensure display change takes effect
        }
      }, fadeOutDuration);
      
      // Update bottom controls
      updateBottomControls();
    }
    
    function updateBottomControls() {
      const controlImage = document.getElementById('control-image');
      const currentTab = tabs[selectedIndex];
      
      let newSrc = '';
      let shouldShow = true;
      
      // Determine which image to show
      if (currentTab === 'games' && navigationFocus === 'carousel') {
        newSrc = 'assets/btns/play.png';
      } else if (currentTab === 'apps' && navigationFocus === 'carousel') {
        // Check which app is currently selected in the apps carousel
        const currentApp = apps[currentAppIndex];
        if (currentApp && (currentApp.id === 'netflix' || currentApp.id === 'steam')) {
          newSrc = 'assets/btns/details.png';
        } else {
          newSrc = 'assets/btns/open.png';
        }
      } else if (currentTab === 'friends' && navigationFocus === 'carousel') {
        // Check which friend is currently selected
        const currentFriend = friends[currentFriendIndex];
        if (currentFriend && (currentFriend.id === 'friend3' || currentFriend.id === 'friend4' || currentFriend.id === 'friend5')) {
          newSrc = 'assets/btns/message.png';
        } else if (currentFriend) {
          // For other friends (friend1, friend2, friend6, friend7, friend8), show invite button
          newSrc = 'assets/btns/invite.png';
        } else {
          shouldShow = false;
        }
      } else if (currentTab === 'games' && navigationFocus === 'nav') {
        newSrc = 'assets/btns/games.png';
      } else if (currentTab === 'apps' && navigationFocus === 'nav') {
        newSrc = 'assets/btns/apps.png';
      } else if (currentTab === 'friends' && navigationFocus === 'nav') {
        newSrc = 'assets/btns/friends.png';
      } else if (['gallery', 'notifications', 'settings'].includes(currentTab)) {
        newSrc = 'assets/btns/view_all.png';
      } else if (currentTab === 'copilot') {
        shouldShow = false;
      }
      
      // If image should be hidden
      if (!shouldShow) {
        controlImage.style.opacity = '0';
        setTimeout(() => {
          controlImage.style.display = 'none';
        }, 125); // Half of transition duration
        return;
      }
      
      // If same image, no need to transition
      if (controlImage.src.endsWith(newSrc)) {
        controlImage.style.display = 'block';
        controlImage.style.opacity = '0.8';
        return;
      }
      
      // Fade out current image
      controlImage.style.opacity = '0';
      
      // After fade out completes, change image and fade in
      setTimeout(() => {
        controlImage.src = newSrc;
        controlImage.style.display = 'block';
        // Small delay to ensure image loads
        setTimeout(() => {
          controlImage.style.opacity = '0.8';
        }, 25);
      }, 125); // Half of transition duration
    }

    function selectTab(i) {
      selectedIndex = i;
      navigationFocus = "nav"; // Reset focus to nav when changing tabs
      renderNav();
    }

    function updateFocusVisuals() {
      // Update visual indicators for navigation focus
      const navItems = document.querySelectorAll('.nav-item');
      const gamesCarouselWrapper = document.querySelector('.games-carousel-wrapper');
      const appsCarouselWrapper = document.querySelector('.apps-carousel-wrapper');
      const friendsCarouselWrapper = document.querySelector('.friends-carousel-wrapper');
      const currentTab = tabs[selectedIndex];
      
      console.log('Navigation focus:', navigationFocus); // Debug logging
      
      if (navigationFocus === "nav") {
        // Navigation bar focused - keep both at full opacity but make carousel images uniform
        nav.style.opacity = "1";
        
        // Add inactive class to the appropriate carousel wrapper
        if (currentTab === "games" && gamesCarouselWrapper) {
          gamesCarouselWrapper.style.opacity = "1";
          gamesCarouselWrapper.classList.add('carousel-inactive');
          updateGamesCarousel(); // Update games to remove focus state
        } else if (currentTab === "apps" && appsCarouselWrapper) {
          appsCarouselWrapper.style.opacity = "1";
          appsCarouselWrapper.classList.add('carousel-inactive');
          updateAppsCarousel(); // Update apps carousel
        } else if (currentTab === "friends" && friendsCarouselWrapper) {
          friendsCarouselWrapper.style.opacity = "1";
          friendsCarouselWrapper.classList.add('carousel-inactive');
          updateFriendsCarousel(); // Update friends carousel
        }
      } else if (navigationFocus === "carousel" && (currentTab === "games" || currentTab === "apps" || currentTab === "friends")) {
        // Carousel focused - keep both at full opacity and restore normal carousel behavior
        nav.style.opacity = "1";
        
        // Remove inactive class from the appropriate carousel wrapper
        if (currentTab === "games" && gamesCarouselWrapper) {
          gamesCarouselWrapper.style.opacity = "1";
          gamesCarouselWrapper.classList.remove('carousel-inactive');
          updateGamesCarousel(); // Update games to show focus state
        } else if (currentTab === "apps" && appsCarouselWrapper) {
          appsCarouselWrapper.style.opacity = "1";
          appsCarouselWrapper.classList.remove('carousel-inactive');
          updateAppsCarousel(); // Update apps carousel
        } else if (currentTab === "friends" && friendsCarouselWrapper) {
          friendsCarouselWrapper.style.opacity = "1";
          friendsCarouselWrapper.classList.remove('carousel-inactive');
          updateFriendsCarousel(); // Update friends carousel
        }
      }
      
      // Update navigation images based on focus change
      navItems.forEach((item, i) => {
        const img = item.querySelector('img');
        const tab = tabs[i];
        
        if (i === selectedIndex) {
          if ((tab === "games" || tab === "apps" || tab === "friends") && navigationFocus === "carousel") {
            img.src = `assets/nav/${tab}_active.png`;
          } else {
            img.src = `assets/nav/${tab}_select.png`;
          }
        } else {
          img.src = `assets/nav/${tab}_default.png`;
        }
      });
      
      // Update bottom controls when focus changes
      updateBottomControls();
    }

    // Enhanced keyboard support with two-level navigation
    document.addEventListener("keydown", (e) => {
      if (navigationFocus === "nav") {
        // Navigation bar is focused - left/right moves through tabs
        if (e.key === "ArrowRight") {
          selectedIndex = (selectedIndex + 1) % tabs.length;
          renderNav();
          e.preventDefault();
        } else if (e.key === "ArrowLeft") {
          selectedIndex = (selectedIndex - 1 + tabs.length) % tabs.length;
          renderNav();
          e.preventDefault();
        } else if (e.key === "ArrowDown") {
          // Move focus down to carousel (games, apps, or friends)
          if (tabs[selectedIndex] === "games" || tabs[selectedIndex] === "apps" || tabs[selectedIndex] === "friends") {
            navigationFocus = "carousel";
            updateFocusVisuals();
          }
          e.preventDefault();
        }
      } else if (navigationFocus === "carousel") {
        // Carousel is focused - left/right moves through items
        if (e.key === "ArrowRight") {
          if (tabs[selectedIndex] === "games") {
            navigateGamesCarousel('right');
          } else if (tabs[selectedIndex] === "apps") {
            navigateAppsCarousel('right');
          } else if (tabs[selectedIndex] === "friends") {
            navigateFriendsCarousel('right');
          }
          e.preventDefault();
        } else if (e.key === "ArrowLeft") {
          if (tabs[selectedIndex] === "games") {
            navigateGamesCarousel('left');
          } else if (tabs[selectedIndex] === "apps") {
            navigateAppsCarousel('left');
          } else if (tabs[selectedIndex] === "friends") {
            navigateFriendsCarousel('left');
          }
          e.preventDefault();
        } else if (e.key === "ArrowUp") {
          // Move focus back up to navigation bar
          navigationFocus = "nav";
          updateFocusVisuals();
          e.preventDefault();
        }
      }
      
      if (e.key === "Enter") {
        if (navigationFocus === "nav") {
          selectTab(selectedIndex);
        }
      } else if (e.key === "d") {
        e.preventDefault(); // Prevent zoom control
      }
    });

    // Enhanced Gamepad support with two-level navigation
    let lastGamepadInput = { axes: [0, 0], buttons: [] };
    
    function handleGamepadInput() {
      const gamepads = navigator.getGamepads();
      if (!gamepads) return;

      const gp = gamepads[0]; // Assume single controller for simplicity
      if (!gp) return;

      // Deadzone for analog sticks
      const deadzone = 0.5;
      const axisX = Math.abs(gp.axes[0]) > deadzone ? gp.axes[0] : 0;
      const axisY = Math.abs(gp.axes[1]) > deadzone ? gp.axes[1] : 0;

      // Prevent rapid-fire input by checking if input changed
      const inputChanged = Math.abs(axisX - lastGamepadInput.axes[0]) > 0.1 || 
                          Math.abs(axisY - lastGamepadInput.axes[1]) > 0.1;

      if (inputChanged) {
        if (navigationFocus === "nav") {
          // Navigation bar focused - left/right controls tabs, down enters carousel
          if (axisX > deadzone) {
            selectedIndex = (selectedIndex + 1) % tabs.length;
            renderNav();
          } else if (axisX < -deadzone) {
            selectedIndex = (selectedIndex - 1 + tabs.length) % tabs.length;
            renderNav();
          } else if (axisY > deadzone && (tabs[selectedIndex] === "games" || tabs[selectedIndex] === "apps" || tabs[selectedIndex] === "friends")) {
            // Move focus down to carousel
            navigationFocus = "carousel";
            updateFocusVisuals();
          }
        } else if (navigationFocus === "carousel") {
          // Carousel focused - left/right controls items, up returns to nav
          if (axisX > deadzone) {
            if (tabs[selectedIndex] === "games") {
              navigateGamesCarousel('right');
            } else if (tabs[selectedIndex] === "apps") {
              navigateAppsCarousel('right');
            } else if (tabs[selectedIndex] === "friends") {
              navigateFriendsCarousel('right');
            }
          } else if (axisX < -deadzone) {
            if (tabs[selectedIndex] === "games") {
              navigateGamesCarousel('left');
            } else if (tabs[selectedIndex] === "apps") {
              navigateAppsCarousel('left');
            } else if (tabs[selectedIndex] === "friends") {
              navigateFriendsCarousel('left');
            }
          } else if (axisY < -deadzone) {
            // Move focus back up to navigation
            navigationFocus = "nav";
            updateFocusVisuals();
          }
        }
      }

      // D-pad support with two-level navigation
      if (gp.buttons[15]?.pressed && !lastGamepadInput.buttons[15]) { // D-pad right
        if (navigationFocus === "nav") {
          selectedIndex = (selectedIndex + 1) % tabs.length;
          renderNav();
        } else if (navigationFocus === "carousel") {
          if (tabs[selectedIndex] === "games") {
            navigateGamesCarousel('right');
          } else if (tabs[selectedIndex] === "apps") {
            navigateAppsCarousel('right');
          } else if (tabs[selectedIndex] === "friends") {
            navigateFriendsCarousel('right');
          }
        }
      } else if (gp.buttons[14]?.pressed && !lastGamepadInput.buttons[14]) { // D-pad left
        if (navigationFocus === "nav") {
          selectedIndex = (selectedIndex - 1 + tabs.length) % tabs.length;
          renderNav();
        } else if (navigationFocus === "carousel") {
          if (tabs[selectedIndex] === "games") {
            navigateGamesCarousel('left');
          } else if (tabs[selectedIndex] === "apps") {
            navigateAppsCarousel('left');
          } else if (tabs[selectedIndex] === "friends") {
            navigateFriendsCarousel('left');
          }
        }
      } else if (gp.buttons[12]?.pressed && !lastGamepadInput.buttons[12]) { // D-pad up
        if (navigationFocus === "carousel") {
          // Move focus back to navigation
          navigationFocus = "nav";
          updateFocusVisuals();
        }
      } else if (gp.buttons[13]?.pressed && !lastGamepadInput.buttons[13]) { // D-pad down
        if (navigationFocus === "nav" && (tabs[selectedIndex] === "games" || tabs[selectedIndex] === "apps" || tabs[selectedIndex] === "friends")) {
          // Move focus down to carousel
          navigationFocus = "carousel";
          updateFocusVisuals();
        }
      } else if (gp.buttons[0]?.pressed && !lastGamepadInput.buttons[0]) { // A button
        if (navigationFocus === "nav") {
          selectTab(selectedIndex);
        }
      }

      // Store current state for next comparison
      lastGamepadInput.axes = [axisX, axisY];
      lastGamepadInput.buttons = gp.buttons.map(b => b?.pressed || false);
    }

    // Poll gamepad input
    setInterval(handleGamepadInput, 100);

    // Initialize the interface
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('ðŸŽ® Starting ROG Ally Game Interface...');
      await initializeGames();
      await initializeApps();
      await initializeFriends();
      createDynamicCSS(); // Create CSS after games, apps, and friends are loaded
      renderNav();
    });
  </script>

  <script src="gamepad.js"></script>
  <script src="keyboard.js"></script>
  <script src="input.js"></script>
  <script src="main.js"></script>
</body>
</html>
